import fs from 'fs'
import path from 'path';
import matter from 'gray-matter';
import rehypeMathjax from 'rehype-mathjax';
import rehypeStringify from 'rehype-stringify';
import remarkMath from 'remark-math';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeHighlight from 'rehype-highlight';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';
import {unified} from 'unified';
import config from '@/app/config';

/**
 * Returns a list of blog IDs. 
 * ID is the file name without the extension.
 * For this function to work, it relies on the
 * structure of the blogs folder. The blogs folder
 * should be structured as follows:
 * 
 * [blogFolderPath]
 * ├── images
 * │   ├── [blog1]
 * │   │   ├── [image1]
 * │   │   ├── [image2]
 * │   │   └── ...
 * │   ├── [blog2]
 * │   │   ├── [image1]
 * │   │   ├── [image2]
 * │   │   └── ...
 * │   └── ...
 * ├── [blog1].md
 * ├── [blog2].md
 * └── ...
 * 
 * @returns {string[]} blogIDs
 */
function getBlogIDs(blogFolderPath) {
  return fs.readdirSync(blogFolderPath)
           .filter(fileName => fileName != 'images')
           .map(fileName => fileName.replace(/\.md$/, ''));
}

export const IDs = getBlogIDs(config.blogFolderPath);

/**
 * Returns the path to the blog file.
 * 
 * @param {string} id or the blog file name without the extension
 * @returns {string} blogPath
 */
export function getBlogPath(id) {
  return path.join(config.blogFolderPath, `${id}.md`);
}

function getBlogMetaData(id) {
  const blogPath = getBlogPath(id);
  const fileContents = fs.readFileSync(blogPath, 'utf8');

  const matterResult = matter(fileContents);
  return matterResult.data;
}

/**
 * Returns a list of blog metadata.
 * 
 * @returns {Object[]} blogMetaDataList
 */
export function getBlogMetaDataList() {
  return IDs.map(id => 
    ({
      id,
      ...getBlogMetaData(id)
    })
  );
}

/**
 * Returns a list of collection IDs.
 * 
 * @returns {string[]} collectionIDs
 */
export function getAllCollectionIds() {
  const metaList = getBlogMetaDataList();
  const collections_ids = new Set(metaList.map(meta => meta.collection).flat());
  var ids = [...collections_ids];
  ids = ids.map(id => id.replace(' ', '_'));
  return ids;
}

/**
 * Returns a list of blog metadata for the given collection.
 * 
 * @param {string} collection_id
 * @returns {Object[]} blogMetaDataList
 */
export function getBlogMetaDataListByCollection(collection_id) {
  const metaList = getBlogMetaDataList();
  return metaList.filter(meta => meta.collection.includes(collection_id));
}

function replaceBlogImageURI(mdContent) {
  const pattern = config.blog_image_path_pattern;
  return mdContent.replace(pattern, `![$1](${config.image_URI}/$2)`)
}

/**
 * This function parses the blog markdown file and returns the data
 * and the HTML content. The HTML content is generated by processing
 * the markdown file with remark and rehype plugins. 
 * 
 * The markdown file is parsed to support the following:
 * - Markdown syntax
 * - Math equations
 * - Code highlighting
 * - Raw HTML
 * - GFM (Github Flavored Markdown)
 * - Images
 * 
 * @param {string} id or the blog file name without the extension
 * @returns {Object} blogData
 */
export async function parseBlogData(id) {
  const blogPath = getBlogPath(id);
  const md = fs.readFileSync(blogPath, 'utf8');

  const {data, content} = matter(md);

  const file = await unified()
    .use(remarkParse)
    .use(remarkGfm)
    .use(remarkMath)
    .use(remarkRehype, {allowDangerousHtml: true})
    .use(rehypeRaw)
    .use(rehypeHighlight)
    .use(rehypeMathjax)
    .use(rehypeStringify)
    .process(replaceBlogImageURI(content));

  return {
    HTML: String(file),
    ...data
  };
}